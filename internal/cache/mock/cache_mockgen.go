// Code generated by MockGen. DO NOT EDIT.
// Source: C:\Users\Kirill\Desktop\watcher\internal\cache\cache.go

// Package mock_cache is a generated GoMock package.
package mock_cache

import (
	context "context"
	reflect "reflect"
	time "time"
	dto "watcher/internal/dto"

	gomock "github.com/golang/mock/gomock"
)

// Mockaliver is a mock of aliver interface.
type Mockaliver struct {
	ctrl     *gomock.Controller
	recorder *MockaliverMockRecorder
}

// MockaliverMockRecorder is the mock recorder for Mockaliver.
type MockaliverMockRecorder struct {
	mock *Mockaliver
}

// NewMockaliver creates a new mock instance.
func NewMockaliver(ctrl *gomock.Controller) *Mockaliver {
	mock := &Mockaliver{ctrl: ctrl}
	mock.recorder = &MockaliverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockaliver) EXPECT() *MockaliverMockRecorder {
	return m.recorder
}

// Alive mocks base method.
func (m *Mockaliver) Alive(arg0 context.Context, arg1 string) (bool, time.Duration) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Alive", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(time.Duration)
	return ret0, ret1
}

// Alive indicates an expected call of Alive.
func (mr *MockaliverMockRecorder) Alive(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Alive", reflect.TypeOf((*Mockaliver)(nil).Alive), arg0, arg1)
}

// Mockhoster is a mock of hoster interface.
type Mockhoster struct {
	ctrl     *gomock.Controller
	recorder *MockhosterMockRecorder
}

// MockhosterMockRecorder is the mock recorder for Mockhoster.
type MockhosterMockRecorder struct {
	mock *Mockhoster
}

// NewMockhoster creates a new mock instance.
func NewMockhoster(ctrl *gomock.Controller) *Mockhoster {
	mock := &Mockhoster{ctrl: ctrl}
	mock.recorder = &MockhosterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockhoster) EXPECT() *MockhosterMockRecorder {
	return m.recorder
}

// Hosts mocks base method.
func (m *Mockhoster) Hosts(arg0 context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Hosts", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Hosts indicates an expected call of Hosts.
func (mr *MockhosterMockRecorder) Hosts(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Hosts", reflect.TypeOf((*Mockhoster)(nil).Hosts), arg0)
}

// Mocksorter is a mock of sorter interface.
type Mocksorter struct {
	ctrl     *gomock.Controller
	recorder *MocksorterMockRecorder
}

// MocksorterMockRecorder is the mock recorder for Mocksorter.
type MocksorterMockRecorder struct {
	mock *Mocksorter
}

// NewMocksorter creates a new mock instance.
func NewMocksorter(ctrl *gomock.Controller) *Mocksorter {
	mock := &Mocksorter{ctrl: ctrl}
	mock.recorder = &MocksorterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocksorter) EXPECT() *MocksorterMockRecorder {
	return m.recorder
}

// MinMax mocks base method.
func (m *Mocksorter) MinMax(arg0 map[string]dto.Info) (dto.InfoWithName, dto.InfoWithName) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MinMax", arg0)
	ret0, _ := ret[0].(dto.InfoWithName)
	ret1, _ := ret[1].(dto.InfoWithName)
	return ret0, ret1
}

// MinMax indicates an expected call of MinMax.
func (mr *MocksorterMockRecorder) MinMax(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MinMax", reflect.TypeOf((*Mocksorter)(nil).MinMax), arg0)
}
